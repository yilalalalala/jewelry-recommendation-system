-- JEWELRY RECOMMENDATION SYSTEM

-- PART 1: CORE RELATIONAL TABLES

-- 1. CATEGORIES TABLE
CREATE TABLE IF NOT EXISTS categories (
    id SERIAL PRIMARY KEY,
    name VARCHAR(50) UNIQUE NOT NULL,
    description TEXT,
    created_at TIMESTAMP DEFAULT NOW()
);

INSERT INTO categories (name, description) VALUES
    ('rings', 'Finger rings including wedding bands and statement rings'),
    ('necklaces', 'Necklaces and pendants of various lengths'),
    ('bracelets', 'Wrist bracelets and bangles'),
    ('earrings', 'Earrings including studs, hoops, and drops')
ON CONFLICT (name) DO NOTHING;

-- 2. MATERIALS TABLE
CREATE TABLE IF NOT EXISTS materials (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) UNIQUE NOT NULL,
    type VARCHAR(20) NOT NULL,  -- 'gem' or 'band'
    color VARCHAR(50),          -- From GEM_COLORS and BAND_COLORS mappings
    created_at TIMESTAMP DEFAULT NOW()
);

-- Insert gems
INSERT INTO materials (name, type, color) VALUES
    ('amazonite', 'gem', 'green'),
    ('amethyst', 'gem', 'purple'),
    ('amethysts', 'gem', 'purple'),
    ('aquamarines', 'gem', 'blue'),
    ('aventurine', 'gem', 'green'),
    ('carnelian', 'gem', 'orange'),
    ('carnelians', 'gem', 'orange'),
    ('chrysoprase', 'gem', 'green'),
    ('chrysoprases', 'gem', 'green'),
    ('citrine', 'gem', 'yellow'),
    ('coral', 'gem', 'red'),
    ('diamond', 'gem', 'white'),
    ('diamonds', 'gem', 'white'),
    ('brown diamonds', 'gem', 'brown'),
    ('emeralds', 'gem', 'green'),
    ('garnets', 'gem', 'red'),
    ('lapis lazuli', 'gem', 'blue'),
    ('malachite', 'gem', 'green'),
    ('obsidians', 'gem', 'black'),
    ('onyx', 'gem', 'black'),
    ('pearl', 'gem', 'white'),
    ('mother_of_pearl', 'gem', 'gray'),
    ('gray mother_of_pearl', 'gem', 'gray'),
    ('white mother_of_pearl', 'gem', 'iridescent white'),
    ('peridots', 'gem', 'green'),
    ('pink sapphire', 'gem', 'pink'),
    ('pink sapphires', 'gem', 'pink'),
    ('rubies', 'gem', 'red'),
    ('sapphire', 'gem', 'blue'),
    ('sapphires', 'gem', 'blue'),
    ('spessartite garnet', 'gem', 'orange'),
    ('spinels', 'gem', 'red'),
    ('tsavorite garnet', 'gem', 'green'),
    ('tsavorite garnets', 'gem', 'green')
ON CONFLICT (name) DO NOTHING;

-- Insert bands
INSERT INTO materials (name, type, color) VALUES
    ('pink gold', 'band', 'pink'),
    ('white gold', 'band', 'silver'),
    ('yellow gold', 'band', 'gold'),
    ('platinum', 'band', 'silver'),
    ('non_rhodiumized white gold', 'band', 'silver'),
    ('ceramic', 'band', 'white'),
    ('black ceramic', 'band', 'black'),
    ('lacquer', 'band', 'red'),
    ('black lacquer', 'band', 'black')
ON CONFLICT (name) DO NOTHING;

-- 3. CLUSTERS TABLE (k-modes cluster output)
CREATE TABLE IF NOT EXISTS clusters (
    id INTEGER PRIMARY KEY,  -- 0 to n_clusters-1
    primary_style VARCHAR(50) NOT NULL,
    style_confidence DECIMAL(5,4),
    secondary_styles TEXT[],
    avg_price DECIMAL(12,2),
    item_count INTEGER,
    dominant_colors TEXT[],
    top_gems TEXT[],
    top_bands TEXT[],
    description TEXT,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- 4. JEWELRY ITEMS TABLE (main product table)
CREATE TABLE IF NOT EXISTS jewelry_items (
    id SERIAL PRIMARY KEY,
    ref VARCHAR(20) UNIQUE NOT NULL,
    title VARCHAR(255) NOT NULL,
    price INTEGER NOT NULL,
    image_url TEXT,
    quantity INTEGER DEFAULT 0,
    size VARCHAR(20),
    chain_size VARCHAR(20),
    category_id INTEGER REFERENCES categories(id),
    cluster_id INTEGER REFERENCES clusters(id),
    collection VARCHAR(100),  -- Extracted from title (Love, PanthÃ¨re, etc.)
    price_tier VARCHAR(20),   -- budget, mid, premium, luxury
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- Indexes for jewelry_items
CREATE INDEX IF NOT EXISTS idx_jewelry_price ON jewelry_items(price);
CREATE INDEX IF NOT EXISTS idx_jewelry_category ON jewelry_items(category_id);
CREATE INDEX IF NOT EXISTS idx_jewelry_cluster ON jewelry_items(cluster_id);
CREATE INDEX IF NOT EXISTS idx_jewelry_collection ON jewelry_items(collection);
CREATE INDEX IF NOT EXISTS idx_jewelry_ref ON jewelry_items(ref);
CREATE INDEX IF NOT EXISTS idx_jewelry_price_tier ON jewelry_items(price_tier);

-- 5. ITEM_MATERIALS TABLE (junction table for clustering features)
CREATE TABLE IF NOT EXISTS item_materials (
    id SERIAL PRIMARY KEY,
    item_id INTEGER REFERENCES jewelry_items(id) ON DELETE CASCADE,
    material_id INTEGER REFERENCES materials(id) ON DELETE CASCADE,
    UNIQUE(item_id, material_id)
);

CREATE INDEX IF NOT EXISTS idx_item_materials_item ON item_materials(item_id);
CREATE INDEX IF NOT EXISTS idx_item_materials_material ON item_materials(material_id);

-- 6. INVENTORY TABLE
CREATE TABLE IF NOT EXISTS inventory (
    item_id INTEGER PRIMARY KEY REFERENCES jewelry_items(id) ON DELETE CASCADE,
    stock_qty INTEGER DEFAULT 0,
    status VARCHAR(20) DEFAULT 'active',
    reorder_level INTEGER DEFAULT 5,
    updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_inventory_status ON inventory(status);
CREATE INDEX IF NOT EXISTS idx_inventory_stock ON inventory(stock_qty);

-- PART 2: USER & SESSION TABLES (For Part 4 Application)

-- 7. USER PROFILES TABLE
CREATE TABLE IF NOT EXISTS user_profiles (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email VARCHAR(255) UNIQUE,
    name VARCHAR(100),
    preferences JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

COMMENT ON COLUMN user_profiles.preferences IS 
'Example: {
    "favorite_styles": ["romantic", "classic"],
    "preferred_colors": ["pink", "white"],
    "preferred_metals": ["pink gold", "white gold"],
    "budget_min": 1000,
    "budget_max": 10000,
    "ring_size": "6",
    "favorite_collections": ["Love", "Trinity"]
}';

-- 8. OUTFIT SESSIONS TABLE (stores inputs to recommend() function)
CREATE TABLE IF NOT EXISTS outfit_sessions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES user_profiles(id),
    
    -- Direct mapping to recommend() parameters
    preferred_colors TEXT[],
    preferred_styles TEXT[],
    min_price INTEGER,
    max_price INTEGER,
    min_quantity INTEGER DEFAULT 1,
    
    -- Optional clothing/outfit context
    clothing_features JSONB DEFAULT '{}'::jsonb,
    
    created_at TIMESTAMP DEFAULT NOW()
);

COMMENT ON COLUMN outfit_sessions.clothing_features IS 
'Example: {
    "colors": ["navy", "white"],
    "style": "formal",
    "occasion": "wedding",
    "season": "summer"
}';

CREATE INDEX IF NOT EXISTS idx_sessions_user ON outfit_sessions(user_id);
CREATE INDEX IF NOT EXISTS idx_sessions_created ON outfit_sessions(created_at);

-- 9. RECOMMENDATION LOG TABLE (tracks ML model outputs)
CREATE TABLE IF NOT EXISTS recommendation_log (
    id SERIAL PRIMARY KEY,
    session_id UUID REFERENCES outfit_sessions(id),
    item_id INTEGER REFERENCES jewelry_items(id),
    
    -- From ML model's recommendation output
    rank INTEGER,
    total_score DECIMAL(5,2),
    style_score DECIMAL(5,2),
    color_score DECIMAL(5,2),
    cluster_bonus DECIMAL(5,2),
    cluster_style VARCHAR(50),
    
    -- User interaction tracking
    clicked BOOLEAN DEFAULT FALSE,
    purchased BOOLEAN DEFAULT FALSE,
    click_timestamp TIMESTAMP,
    purchase_timestamp TIMESTAMP,
    
    created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_rec_session ON recommendation_log(session_id);
CREATE INDEX IF NOT EXISTS idx_rec_item ON recommendation_log(item_id);
CREATE INDEX IF NOT EXISTS idx_rec_clicked ON recommendation_log(clicked);
CREATE INDEX IF NOT EXISTS idx_rec_purchased ON recommendation_log(purchased);
CREATE INDEX IF NOT EXISTS idx_rec_score ON recommendation_log(total_score);

-- PART 3: VIEWS

-- View: Full jewelry details with cluster and materials
CREATE OR REPLACE VIEW v_jewelry_full AS
SELECT 
    j.id,
    j.ref,
    j.title,
    j.price,
    j.image_url,
    j.quantity,
    j.size,
    j.collection,
    j.price_tier,
    c.name AS category,
    cl.id AS cluster_id,
    cl.primary_style AS cluster_style,
    cl.style_confidence,
    i.stock_qty,
    i.status,
    ARRAY_AGG(DISTINCT m.name) FILTER (WHERE m.type = 'band') AS metals,
    ARRAY_AGG(DISTINCT m.name) FILTER (WHERE m.type = 'gem') AS gemstones,
    ARRAY_AGG(DISTINCT m.color) FILTER (WHERE m.color IS NOT NULL) AS colors
FROM jewelry_items j
LEFT JOIN categories c ON j.category_id = c.id
LEFT JOIN clusters cl ON j.cluster_id = cl.id
LEFT JOIN inventory i ON j.id = i.item_id
LEFT JOIN item_materials im ON j.id = im.item_id
LEFT JOIN materials m ON im.material_id = m.id
GROUP BY j.id, c.name, cl.id, cl.primary_style, cl.style_confidence, i.stock_qty, i.status;

-- View: Available items only (in stock and active)
CREATE OR REPLACE VIEW v_available_items AS
SELECT * FROM v_jewelry_full
WHERE status = 'active' AND stock_qty > 0;

-- View: Cluster summary
CREATE OR REPLACE VIEW v_cluster_summary AS
SELECT 
    cl.id AS cluster_id,
    cl.primary_style,
    cl.style_confidence,
    cl.secondary_styles,
    cl.avg_price,
    cl.item_count,
    cl.dominant_colors,
    cl.top_gems,
    cl.top_bands,
    COUNT(j.id) AS current_item_count,
    ROUND(AVG(j.price), 2) AS current_avg_price
FROM clusters cl
LEFT JOIN jewelry_items j ON cl.id = j.cluster_id
GROUP BY cl.id, cl.primary_style, cl.style_confidence, cl.secondary_styles, 
         cl.avg_price, cl.item_count, cl.dominant_colors, cl.top_gems, cl.top_bands;

-- View: Recommendation analytics
CREATE OR REPLACE VIEW v_recommendation_stats AS
SELECT 
    j.ref,
    j.title,
    j.collection,
    c.name AS category,
    cl.primary_style AS cluster_style,
    COUNT(rl.id) AS times_recommended,
    SUM(CASE WHEN rl.clicked THEN 1 ELSE 0 END) AS total_clicks,
    SUM(CASE WHEN rl.purchased THEN 1 ELSE 0 END) AS total_purchases,
    ROUND(AVG(rl.total_score), 2) AS avg_total_score,
    ROUND(AVG(rl.style_score), 2) AS avg_style_score,
    ROUND(AVG(rl.color_score), 2) AS avg_color_score,
    ROUND(AVG(rl.cluster_bonus), 2) AS avg_cluster_bonus,
    ROUND(
        SUM(CASE WHEN rl.clicked THEN 1 ELSE 0 END)::DECIMAL / 
        NULLIF(COUNT(rl.id), 0) * 100, 2
    ) AS click_through_rate,
    ROUND(
        SUM(CASE WHEN rl.purchased THEN 1 ELSE 0 END)::DECIMAL / 
        NULLIF(SUM(CASE WHEN rl.clicked THEN 1 ELSE 0 END), 0) * 100, 2
    ) AS conversion_rate
FROM jewelry_items j
LEFT JOIN categories c ON j.category_id = c.id
LEFT JOIN clusters cl ON j.cluster_id = cl.id
LEFT JOIN recommendation_log rl ON j.id = rl.item_id
GROUP BY j.id, j.ref, j.title, j.collection, c.name, cl.primary_style;

-- View: Style performance analysis
CREATE OR REPLACE VIEW v_style_performance AS
SELECT 
    rl.cluster_style,
    COUNT(DISTINCT rl.session_id) AS sessions_shown,
    COUNT(rl.id) AS total_recommendations,
    SUM(CASE WHEN rl.clicked THEN 1 ELSE 0 END) AS clicks,
    SUM(CASE WHEN rl.purchased THEN 1 ELSE 0 END) AS purchases,
    ROUND(AVG(rl.total_score), 2) AS avg_score,
    ROUND(
        SUM(CASE WHEN rl.clicked THEN 1 ELSE 0 END)::DECIMAL / 
        NULLIF(COUNT(rl.id), 0) * 100, 2
    ) AS ctr_percent
FROM recommendation_log rl
WHERE rl.cluster_style IS NOT NULL
GROUP BY rl.cluster_style
ORDER BY purchases DESC;

-- PART 4: HELPER FUNCTIONS

-- Function to update inventory status based on stock
CREATE OR REPLACE FUNCTION update_inventory_status()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.stock_qty = 0 THEN
        NEW.status = 'out_of_stock';
    ELSIF NEW.stock_qty <= NEW.reorder_level THEN
        NEW.status = 'low_stock';
    ELSE
        NEW.status = 'active';
    END IF;
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_inventory_status ON inventory;
CREATE TRIGGER trg_inventory_status
    BEFORE UPDATE OF stock_qty ON inventory
    FOR EACH ROW
    EXECUTE FUNCTION update_inventory_status();

-- Function to get items by cluster style (useful for ML integration)
CREATE OR REPLACE FUNCTION get_items_by_style(
    p_style VARCHAR,
    p_min_price INTEGER DEFAULT NULL,
    p_max_price INTEGER DEFAULT NULL,
    p_limit INTEGER DEFAULT 20
)
RETURNS TABLE (
    item_id INTEGER,
    ref VARCHAR,
    title VARCHAR,
    price INTEGER,
    image_url TEXT,
    cluster_style VARCHAR,
    stock_qty INTEGER
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        j.id,
        j.ref,
        j.title,
        j.price,
        j.image_url,
        cl.primary_style,
        i.stock_qty
    FROM jewelry_items j
    JOIN clusters cl ON j.cluster_id = cl.id
    JOIN inventory i ON j.id = i.item_id
    WHERE 
        cl.primary_style = p_style
        AND i.status = 'active'
        AND i.stock_qty > 0
        AND (p_min_price IS NULL OR j.price >= p_min_price)
        AND (p_max_price IS NULL OR j.price <= p_max_price)
    ORDER BY j.price
    LIMIT p_limit;
END;
$$ LANGUAGE plpgsql;

-- Function to log a recommendation batch
CREATE OR REPLACE FUNCTION log_recommendations(
    p_session_id UUID,
    p_recommendations JSONB
)
RETURNS INTEGER AS $$
DECLARE
    rec JSONB;
    inserted_count INTEGER := 0;
BEGIN
    FOR rec IN SELECT * FROM jsonb_array_elements(p_recommendations)
    LOOP
        INSERT INTO recommendation_log (
            session_id, item_id, rank, total_score, 
            style_score, color_score, cluster_bonus, cluster_style
        ) VALUES (
            p_session_id,
            (rec->>'item_id')::INTEGER,
            (rec->>'rank')::INTEGER,
            (rec->>'total_score')::DECIMAL,
            (rec->>'style_score')::DECIMAL,
            (rec->>'color_score')::DECIMAL,
            (rec->>'cluster_bonus')::DECIMAL,
            rec->>'cluster_style'
        );
        inserted_count := inserted_count + 1;
    END LOOP;
    
    RETURN inserted_count;
END;
$$ LANGUAGE plpgsql;

-- VERIFICATION QUERIES

-- Check table counts
SELECT 'jewelry_items' as table_name, COUNT(*) as count FROM jewelry_items
UNION ALL SELECT 'materials', COUNT(*) FROM materials
UNION ALL SELECT 'clusters', COUNT(*) FROM clusters
UNION ALL SELECT 'item_materials', COUNT(*) FROM item_materials;

-- Check cluster distribution
SELECT cl.primary_style, COUNT(j.id) as items
FROM clusters cl
LEFT JOIN jewelry_items j ON cl.id = j.cluster_id
GROUP BY cl.id, cl.primary_style
ORDER BY cl.id;

-- Check category distribution
SELECT c.name, COUNT(j.id) FROM categories c 
LEFT JOIN jewelry_items j ON c.id = j.category_id 
GROUP BY c.name;

-- Test style lookup
-- SELECT * FROM get_items_by_style('romantic', 2000, 5000, 5);
