# -*- coding: utf-8 -*-
"""recommendation_system.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-D5xZxcFO70ADrWQ68Xdr08eTLRT5vY8
"""

import pandas as pd
import numpy as np
from datetime import datetime
from typing import List, Dict, Optional
import json
import re

class JewelryRecommendationSystem:
    """
    Agentic AI + E-Commerce Database Jewelry Recommendation System

    """

    def __init__(self, jewelry_data_path: str = None):
        """
        Initialize the recommendation system

        Args:
            jewelry_data_path: Path to CSV file with jewelry inventory
        """
        self.jewelry_df = None
        self.recommendation_log = []

        # Define style vocabularies for consistent tagging
        self.style_tags = ['elegant', 'minimalist', 'boho', 'classic',
                          'modern', 'vintage', 'casual', 'formal', 'luxury',
                          'romantic', 'bold', 'delicate', 'timeless']

        self.materials = [
            'amazonite', 'amethyst', 'aquamarines', 'aventurine',
            'black ceramic', 'black lacquer', 'carnelian', 'ceramic',
            'chrysoprase', 'citrine', 'coral', 'diamond', 'emeralds',
            'garnets', 'gray mother_of_pearl', 'lacquer', 'lapis lazuli',
            'malachite', 'mother_of_pearl', 'obsidians', 'onyx', 'pearl',
            'peridots', 'pink gold', 'pink sapphire', 'platinum',
            'rubies', 'sapphire', 'spessartite garnet', 'spinels',
            'tsavorite garnet', 'white gold', 'yellow gold',
            'non_rhodiumized white gold', 'white mother_of_pearl',
            'brown diamonds'
        ]

        # Category columns from data
        self.categories = ['bracelets', 'earrings', 'necklaces', 'rings']

        # Cartier collections
        self.collections = ['Love', 'Panthère', 'Trinity', '1895',
                           'Juste un Clou', 'Les Oiseaux Libérés',
                           'Cactus', 'Étincelle', "Cartier d'Amour",
                           'Ballerine', 'C de Cartier', 'Trinity Ruban']

        if jewelry_data_path:
            self.load_data(jewelry_data_path)

    def load_data(self, data_path: str):
        """Load jewelry inventory data from CSV"""
        self.jewelry_df = pd.read_csv(data_path)

        # Remove extra whitespace from column names
        self.jewelry_df.columns = self.jewelry_df.columns.str.strip()

        print(f"Loaded {len(self.jewelry_df)} jewelry items from Cartier collection")

        # Preprocess: ensure quantity is numeric
        self.jewelry_df['quantity'] = pd.to_numeric(
            self.jewelry_df['quantity'], errors='coerce'
        ).fillna(0).astype(int)

        self.jewelry_df['price'] = pd.to_numeric(
            self.jewelry_df['price'], errors='coerce'
        )

        # Consolidate singular/plural columns
        self._consolidate_features()

        # Add derived features
        self._add_derived_features()

        print(f"  ├─ Rings: {self.jewelry_df['rings'].sum()}")
        print(f"  ├─ Necklaces: {self.jewelry_df['necklaces'].sum()}")
        print(f"  ├─ Earrings: {self.jewelry_df['earrings'].sum()}")
        print(f"  └─ Bracelets: {self.jewelry_df['bracelets'].sum()}")
        print(f"\nPrice range: ${self.jewelry_df['price'].min():.0f} - ${self.jewelry_df['price'].max():.0f}")

    def _consolidate_features(self):
        """
        UPDATED: Consolidate singular/plural material columns
        e.g., 'diamond' and 'diamonds' -> keep 'diamond' with OR logic
        """
        consolidations = {
            'diamond': ['diamond', 'diamonds'],
            'amethyst': ['amethyst', 'amethysts'],
            'carnelian': ['carnelian', 'carnelians'],
            'chrysoprase': ['chrysoprase', 'chrysoprases'],
            'pink sapphire': ['pink sapphire', 'pink sapphires'],
            'sapphire': ['sapphire', 'sapphires'],
            'tsavorite garnet': ['tsavorite garnet', 'tsavorite garnets']
        }

        for main_col, variants in consolidations.items():
            # Check which variants exist
            existing = [v for v in variants if v in self.jewelry_df.columns]
            if len(existing) > 1:
                # Combine with OR logic (any variant present = 1)
                self.jewelry_df[main_col] = self.jewelry_df[existing].max(axis=1)
                # Drop the duplicates except the main one
                to_drop = [v for v in existing if v != main_col]
                self.jewelry_df.drop(columns=to_drop, inplace=True, errors='ignore')

    def _add_derived_features(self):
        """
        Add derived features based on Cartier data
        """
        # Extract collection/brand from title
        self.jewelry_df['collection'] = self.jewelry_df['title'].apply(
            self._extract_collection
        )

        # Price tier (budget/mid/luxury/ultra-luxury)
        self.jewelry_df['price_tier'] = pd.cut(
            self.jewelry_df['price'],
            bins=[0, 2000, 10000, 50000, float('inf')],
            labels=['budget', 'mid', 'luxury', 'ultra_luxury']
        )

        # Luxury score (0-1) based on materials and price
        self.jewelry_df['luxury_score'] = self._calculate_luxury_score()

    def _extract_collection(self, title: str) -> str:
        """
        Extract Cartier collection name from title
        """
        title_lower = title.lower()
        for collection in self.collections:
            if collection.lower() in title_lower:
                return collection
        return 'Other'

    def _calculate_luxury_score(self) -> pd.Series:
        """
        Calculate luxury score (0-1) based on materials and price
        """
        score = pd.Series(0.0, index=self.jewelry_df.index)

        # Material contributions
        if 'diamond' in self.jewelry_df.columns:
            score += self.jewelry_df['diamond'] * 0.3
        if 'platinum' in self.jewelry_df.columns:
            score += self.jewelry_df['platinum'] * 0.2
        if 'emeralds' in self.jewelry_df.columns:
            score += self.jewelry_df['emeralds'] * 0.15
        if 'sapphire' in self.jewelry_df.columns:
            score += self.jewelry_df['sapphire'] * 0.15
        if 'rubies' in self.jewelry_df.columns:
            score += self.jewelry_df['rubies'] * 0.15

        # Price contribution (normalized)
        price_normalized = (self.jewelry_df['price'] - self.jewelry_df['price'].min()) / \
                          (self.jewelry_df['price'].max() - self.jewelry_df['price'].min())
        score += price_normalized * 0.3

        return score.clip(0, 1)

    def extract_item_features(self, item_row):
        """
        Extract features from a jewelry item row
        Returns: dict with category, materials, styles, and collection
        """
        features = {
            'category': None,
            'materials': [],
            'styles': [],
            'collection': item_row.get('collection', 'Other'),
            'luxury_score': item_row.get('luxury_score', 0.0),
            'price_tier': item_row.get('price_tier', 'mid')
        }

        # Extract category
        for cat in self.categories:
            if cat in item_row and item_row[cat] == 1:
                features['category'] = cat
                break

        # Extract materials (only check consolidated columns)
        check_materials = [
            'amazonite', 'amethyst', 'aquamarines', 'aventurine',
            'black ceramic', 'carnelian', 'ceramic', 'chrysoprase',
            'citrine', 'coral', 'diamond', 'emeralds', 'garnets',
            'lapis lazuli', 'malachite', 'mother_of_pearl', 'onyx',
            'pearl', 'peridots', 'pink gold', 'pink sapphire',
            'platinum', 'rubies', 'sapphire', 'white gold', 'yellow gold'
        ]

        for mat in check_materials:
            if mat in item_row and item_row[mat] == 1:
                features['materials'].append(mat)

        # Infer styles based on materials, collection, and price
        features['styles'] = self._infer_styles_from_real_data(features, item_row)

        return features

    def _infer_styles_from_real_data(self, features: Dict, item_row) -> List[str]:
        """
        Infer style tags from actual Cartier jewelry characteristics
        Based on materials, collection, and price tier
        """
        styles = set()
        materials = features.get('materials', [])
        collection = features.get('collection', 'Other')
        price = item_row.get('price', 0)

        # Collection-based styles
        collection_styles = {
            'Love': ['romantic', 'modern', 'iconic', 'classic'],
            'Panthère': ['bold', 'luxury', 'elegant', 'timeless'],
            'Trinity': ['classic', 'timeless', 'elegant', 'minimalist'],
            '1895': ['classic', 'formal', 'elegant', 'timeless'],
            'Juste un Clou': ['modern', 'bold', 'edgy', 'luxury'],
            'Les Oiseaux Libérés': ['elegant', 'luxury', 'artistic'],
            'Cactus': ['bold', 'modern', 'unique'],
            'Étincelle': ['delicate', 'elegant', 'romantic'],
            "Cartier d'Amour": ['romantic', 'elegant', 'delicate'],
            'C de Cartier': ['modern', 'minimalist', 'elegant'],
            'Trinity Ruban': ['elegant', 'romantic', 'modern']
        }

        if collection in collection_styles:
            styles.update(collection_styles[collection])

        # Material-based style inference
        if 'diamond' in materials:
            styles.update(['luxury', 'elegant', 'formal', 'timeless'])
        if 'platinum' in materials:
            styles.update(['luxury', 'elegant', 'modern'])
        if 'yellow gold' in materials:
            styles.update(['classic', 'warm', 'traditional'])
        if 'white gold' in materials:
            styles.update(['modern', 'elegant', 'versatile'])
        if 'pink gold' in materials:
            styles.update(['romantic', 'modern', 'feminine'])
        if 'pearl' in materials:
            styles.update(['elegant', 'vintage', 'classic', 'timeless'])
        if any(stone in materials for stone in ['sapphire', 'emeralds', 'rubies']):
            styles.update(['luxury', 'bold', 'colorful', 'elegant'])
        if any(stone in materials for stone in ['amethyst', 'aquamarines', 'malachite']):
            styles.update(['boho', 'unique', 'colorful'])
        if 'onyx' in materials or 'black ceramic' in materials:
            styles.update(['modern', 'bold', 'edgy'])
        if 'mother_of_pearl' in materials:
            styles.update(['delicate', 'elegant', 'iridescent'])

        # Price-based style inference
        if price > 50000:
            styles.update(['luxury', 'high_end', 'exclusive'])
        elif price > 10000:
            styles.update(['luxury', 'premium'])
        elif price < 2000:
            styles.update(['accessible', 'everyday'])

        # Category-based style inference
        category = features.get('category')
        if category == 'rings':
            styles.update(['formal', 'symbolic'])
        elif category == 'earrings':
            styles.update(['elegant', 'versatile'])
        elif category == 'necklaces':
            styles.update(['statement', 'elegant'])
        elif category == 'bracelets':
            styles.update(['casual', 'versatile'])

        # Ensure we have at least a few styles
        if not styles:
            styles = {'classic', 'elegant', 'modern'}

        return list(styles)

    def recommend_jewelry(self,
                         budget_min: float,
                         budget_max: float,
                         style_preferences: List[str] = None,
                         event: str = None,
                         category: str = None,
                         material_preferences: List[str] = None,
                         collection_preference: str = None,
                         top_k: int = 6,
                         session_id: str = None) -> List[Dict]:
        """
        Main recommendation function implementing the scoring logic

        Args:
            budget_min: Minimum price
            budget_max: Maximum price
            style_preferences: List of style tags (e.g., ['minimalist', 'modern'])
            event: Event type (e.g., 'wedding', 'casual')
            category: Jewelry category (e.g., 'rings', 'necklaces')
            material_preferences: List of preferred materials
            collection_preference: Preferred Cartier collection (e.g., 'Love', 'Panthère')
            top_k: Number of recommendations to return
            session_id: Session identifier for logging

        Returns:
            List of recommended items with scores and explanations
        """
        if self.jewelry_df is None:
            raise ValueError("No data loaded. Call load_data() first.")

        if session_id is None:
            session_id = f"session_{datetime.now().strftime('%Y%m%d_%H%M%S')}"

        # STEP 1: Apply hard filters
        filtered_df = self.jewelry_df.copy()

        # Filter 1: Must be in stock
        filtered_df = filtered_df[filtered_df['quantity'] > 0]

        # Filter 2: Must be within budget
        filtered_df = filtered_df[
            (filtered_df['price'] >= budget_min) &
            (filtered_df['price'] <= budget_max)
        ]

        # Filter 3: Category filter (if specified)
        if category:
            if category in self.categories:
                filtered_df = filtered_df[filtered_df[category] == 1]

        # Filter 4: Material filter (if specified)
        if material_preferences:
            material_mask = pd.Series([False] * len(filtered_df), index=filtered_df.index)
            for material in material_preferences:
                # Normalize material name
                material_normalized = material.lower().strip()
                if material_normalized in filtered_df.columns:
                    material_mask |= (filtered_df[material_normalized] == 1)
            filtered_df = filtered_df[material_mask]

        # Filter 5: Collection filter
        if collection_preference:
            filtered_df = filtered_df[
                filtered_df['collection'].str.lower() == collection_preference.lower()
            ]

        if len(filtered_df) == 0:
            print("No items match your filters. Try broadening your criteria.")
            return []

        # STEP 2: Score and rank items
        recommendations = []
        budget_mid = (budget_min + budget_max) / 2
        budget_range = budget_max - budget_min

        for idx, row in filtered_df.iterrows():
            # Extract item features
            item_features = self.extract_item_features(row)
            item_styles = item_features['styles']

            # Calculate style fit (overlap count)
            style_overlap = 0
            if style_preferences:
                # Normalize style preferences
                style_prefs_normalized = [s.lower().strip() for s in style_preferences]
                item_styles_normalized = [s.lower().strip() for s in item_styles]
                style_overlap = len(
                    set(style_prefs_normalized) & set(item_styles_normalized)
                )

            # Calculate price fit (favor items near budget midpoint)
            price_diff = abs(row['price'] - budget_mid)
            price_fit = 1 - (price_diff / budget_range) if budget_range > 0 else 1
            price_fit = max(0, price_fit)

            # scoring with luxury score: overlap + 0.5 × price_fit + 0.2 × luxury_score
            base_score = style_overlap + (0.5 * price_fit)
            luxury_bonus = 0.2 * item_features['luxury_score']
            final_score = base_score + luxury_bonus

            # Build recommendation object
            recommendation = {
                'ref': row['ref'],
                'title': row['title'],
                'price': float(row['price']),
                'image': row['image'],
                'quantity': int(row['quantity']),
                'category': item_features['category'],
                'materials': item_features['materials'],
                'styles': item_styles,
                'collection': item_features['collection'],
                'luxury_score': item_features['luxury_score'],
                'price_tier': str(item_features['price_tier']),
                'score': final_score,
                'style_overlap': style_overlap,
                'price_fit': price_fit,
                'explanation': self._generate_explanation(
                    style_overlap, price_fit, item_features, style_preferences
                )
            }

            recommendations.append(recommendation)

        # STEP 3: Sort by score and return top K
        recommendations.sort(key=lambda x: x['score'], reverse=True)
        top_recommendations = recommendations[:top_k]

        # STEP 4: Log recommendations
        self._log_recommendations(session_id, top_recommendations, {
            'budget_min': budget_min,
            'budget_max': budget_max,
            'style_preferences': style_preferences,
            'event': event,
            'category': category,
            'material_preferences': material_preferences,
            'collection_preference': collection_preference
        })

        return top_recommendations

    def _generate_explanation(self, style_overlap, price_fit, features, user_styles):
        """
        Generate readable explanation for why item was recommended
        """
        explanations = []

        # Style match explanation
        if style_overlap > 0:
            matching_styles = set([s.lower() for s in features['styles']]) & \
                            set([s.lower() for s in (user_styles or [])])
            if matching_styles:
                style_str = ', '.join(list(matching_styles)[:2])
                explanations.append(f"Matches your {style_str} style")

        # Collection explanation
        if features['collection'] != 'Other':
            explanations.append(f"From {features['collection']} collection")

        # Price fit explanation
        if price_fit > 0.8:
            explanations.append("Excellent value within your budget")
        elif price_fit > 0.6:
            explanations.append("Good fit for your budget")

        # Luxury explanation
        if features['luxury_score'] > 0.7:
            explanations.append("Premium luxury piece")

        # Default explanation
        if not explanations:
            explanations.append("In stock and meets your criteria")

        return "; ".join(explanations)

    def _log_recommendations(self, session_id, recommendations, user_inputs):
        """Log recommendations for analytics (simulating MongoDB storage)"""
        log_entry = {
            'session_id': session_id,
            'timestamp': datetime.now().isoformat(),
            'user_inputs': user_inputs,
            'recommendations': [
                {
                    'ref': rec['ref'],
                    'rank': idx + 1,
                    'score': rec['score'],
                    'price': rec['price'],
                    'collection': rec['collection']
                }
                for idx, rec in enumerate(recommendations)
            ],
            'num_results': len(recommendations)
        }

        self.recommendation_log.append(log_entry)

    def get_recommendation_log(self) -> List[Dict]:
        """Retrieve recommendation logs for analytics"""
        return self.recommendation_log

    def analyze_trends(self) -> Dict:
        """
        Analyze recommendation logs to identify trends
        Useful for merchandising team use case
        """
        if not self.recommendation_log:
            return {"message": "No logs available yet"}

        all_inputs = [log['user_inputs'] for log in self.recommendation_log]

        # Count most requested styles
        style_counts = {}
        for inputs in all_inputs:
            styles = inputs.get('style_preferences', [])
            for style in styles:
                style_counts[style] = style_counts.get(style, 0) + 1

        # Count most requested categories
        category_counts = {}
        for inputs in all_inputs:
            cat = inputs.get('category')
            if cat:
                category_counts[cat] = category_counts.get(cat, 0) + 1

        # Count most requested collections
        collection_counts = {}
        for inputs in all_inputs:
            coll = inputs.get('collection_preference')
            if coll:
                collection_counts[coll] = collection_counts.get(coll, 0) + 1

        # Analyze recommended items
        all_recs = []
        for log in self.recommendation_log:
            all_recs.extend(log['recommendations'])

        collection_performance = {}
        for rec in all_recs:
            coll = rec.get('collection', 'Other')
            if coll not in collection_performance:
                collection_performance[coll] = {'count': 0, 'avg_score': 0, 'total_score': 0}
            collection_performance[coll]['count'] += 1
            collection_performance[coll]['total_score'] += rec.get('score', 0)

        for coll in collection_performance:
            collection_performance[coll]['avg_score'] = \
                collection_performance[coll]['total_score'] / collection_performance[coll]['count']

        return {
            'total_sessions': len(self.recommendation_log),
            'popular_styles': sorted(style_counts.items(), key=lambda x: x[1], reverse=True)[:5],
            'popular_categories': sorted(category_counts.items(), key=lambda x: x[1], reverse=True),
            'popular_collections': sorted(collection_counts.items(), key=lambda x: x[1], reverse=True),
            'collection_performance': collection_performance,
            'avg_budget': np.mean([inp.get('budget_max', 0) for inp in all_inputs]),
            'total_recommendations': len(all_recs)
        }

    def get_collection_insights(self) -> Dict:
        """
        Get insights about Cartier collections in the dataset
        Useful for merchandising team
        """
        if self.jewelry_df is None:
            return {"error": "No data loaded"}

        insights = {}
        for collection in self.collections:
            collection_items = self.jewelry_df[
                self.jewelry_df['collection'] == collection
            ]

            if len(collection_items) > 0:
                insights[collection] = {
                    'total_items': len(collection_items),
                    'in_stock': len(collection_items[collection_items['quantity'] > 0]),
                    'avg_price': float(collection_items['price'].mean()),
                    'price_range': {
                        'min': float(collection_items['price'].min()),
                        'max': float(collection_items['price'].max())
                    },
                    'categories': {
                        cat: int(collection_items[cat].sum())
                        for cat in self.categories
                        if cat in collection_items.columns
                    }
                }

        return insights